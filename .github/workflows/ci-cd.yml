name: CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    container:
      image: golangci/golangci-lint:v2.4.0-alpine
    steps:
      - uses: actions/checkout@v4

      - name: Run linter
        run: export GOFLAGS="-buildvcs=false" && golangci-lint run

  test:
    name: Test
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:24-dind
        options: --privileged
    container:
      image: golang:alpine
      options: --privileged
    steps:
      - uses: actions/checkout@v4

      - name: Prepare .env
        run: cp .env.example .env

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: PROJECT_ROOT=$(pwd) go test ./... -v -count=1

  build:
    name: Build
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:24-dind
        options: --privileged
    steps:
      - uses: actions/checkout@v4

      - name: Prepare .env
        run: cp .env.example .env

      - name: Build and run
        run: docker compose up --build -d

      - name: Wait for healthy service
        run: |
          for i in $(seq 1 20); do
            status=$(docker inspect --format='{{.State.Health.Status}}' cloud-notes-server 2>/dev/null || echo "starting")
            if [ "$status" = "healthy" ]; then
              echo "Service is healthy"
              exit 0
            fi
            echo "Current status: $status"
            sleep 3
          done
          echo "Service is unhealthy"
          docker compose logs server
          exit 1

      - name: Shutdown
        if: always()
        run: docker compose down

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [ lint, test, build ]
    steps:
      - uses: actions/checkout@v4

      - name: Deploy with appleboy/ssh-action
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          password: ${{ secrets.DEPLOY_PASSWORD }}
          port: 22
          script: |
            DEPLOY_DIR=/cloud-notes-server
            
            if [ ! -d "$DEPLOY_DIR" ]; then
              git clone ${{ github.server_url }}/${{ github.repository }} $DEPLOY_DIR
            else
              cd $DEPLOY_DIR
              git fetch origin
              git reset --hard origin/main
            fi

            cd $DEPLOY_DIR
            
            cat > .env <<EOF
            ENV=${{ secrets.ENV }}
            
            MIGRATIONS_DIR=${{ secrets.MIGRATIONS_DIR }}
            
            SERVER_HOST=${{ secrets.SERVER_HOST }}
            SERVER_PORT=${{ secrets.SERVER_PORT }}
            SERVER_READ_TIMEOUT=${{ secrets.SERVER_READ_TIMEOUT }}
            SERVER_WRITE_TIMEOUT=${{ secrets.SERVER_WRITE_TIMEOUT }}
            SERVER_IDLE_TIMEOUT=${{ secrets.SERVER_IDLE_TIMEOUT }}
            
            LOGGER_LEVEL=${{ secrets.LOGGER_LEVEL }}
            LOGGER_OUTPUT=${{ secrets.LOGGER_OUTPUT }}
            LOGGER_FORMAT=${{ secrets.LOGGER_FORMAT }}
            
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}
            POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            POSTGRES_URL=${{ secrets.POSTGRES_URL }}
            
            REDIS_HOST=${{ secrets.REDIS_HOST }}
            REDIS_PORT=${{ secrets.REDIS_PORT }}
            REDIS_DB=${{ secrets.REDIS_DB }}
            REDIS_URL=${{ secrets.REDIS_URL }}
            
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            EOF
            
            docker compose up --build -d
